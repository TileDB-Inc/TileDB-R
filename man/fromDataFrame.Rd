% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataFrame.R
\name{fromDataFrame}
\alias{fromDataFrame}
\title{Create a TileDB dense or sparse array from a given \code{data.frame} Object}
\usage{
fromDataFrame(
  obj,
  uri,
  col_index = NULL,
  sparse = TRUE,
  allows_dups = sparse,
  cell_order = "COL_MAJOR",
  tile_order = "COL_MAJOR",
  filter = "ZSTD",
  capacity = 10000L,
  tile_domain = NULL,
  tile_extent = NULL,
  mode = c("ingest", "schema_only", "append"),
  filter_list = NULL,
  coords_filters = "ZSTD",
  offsets_filters = "ZSTD",
  validity_filters = "RLE",
  debug = FALSE,
  timestamps = as.POSIXct(double(), origin = "1970-01-01")
)
}
\arguments{
\item{obj}{A \code{data.frame} object.}

\item{uri}{A character variable with an Array URI.}

\item{col_index}{An optional column index, either numeric with a column index,
or character with a column name, designating an index column; default is NULL
implying an index column is added when the array is created}

\item{sparse}{A logical switch to select sparse (the default) or dense}

\item{allows_dups}{A logical switch to select if duplicate values
are allowed or not, default is the same value as \sQuote{sparse}.}

\item{cell_order}{A character variable with one of the TileDB cell order values,
default is \dQuote{COL_MAJOR}.}

\item{tile_order}{A character variable with one of the TileDB tile order values,
default is \dQuote{COL_MAJOR}.}

\item{filter}{A character variable vector, defaults to \sQuote{ZSTD}, for
one or more filters to be applied to each attribute;}

\item{capacity}{A integer value with the schema capacity, default is 10000.}

\item{tile_domain}{An integer vector or list or \code{NULL}. If an integer vector
of size two it specifies the integer domain of the row dimension; if a list then a named
element is used for the dimension of the same name; or if \code{NULL} the row
dimension of the \code{obj} is used.}

\item{tile_extent}{An integer value for the tile extent of the row dimensions;
if \code{NULL} the row dimension of the \code{obj} is used. Note that the \code{tile_extent}
cannot exceed the tile domain.}

\item{mode}{A character variable with possible values \sQuote{ingest} (for schema creation and
data ingestion, the default behavior), \sQuote{schema_only} (to create the array schema without
writing to the newly-created array) and \sQuote{append} (to only append to an already existing
array).}

\item{filter_list}{A named list specifying filter choices per column, default is an empty
\code{list} object. This argument applies for all named arguments and the matchin dimensions
or attributes. The \code{filter} argument still applies for all unnamed arguments.}

\item{coords_filters}{A character vector with filters for coordinates, default is \code{ZSTD}.}

\item{offsets_filters}{A character vector with filters for coordinates, default is \code{ZSTD}.}

\item{validity_filters}{A character vector with filters for coordinates, default is \code{RLE}.}

\item{debug}{Logical flag to select additional output.}

\item{timestamps}{Vector with up to two \code{POSIXct} variables denoting open intervals; default
is length zero where start and end are set (implicitly) to current time; in case of one value it
is used as the interval end, and in case of two values they are taken as start and end. This
applies to write and append modes only and not to schema creation.}
}
\value{
Null, invisibly.
}
\description{
The supplied \code{data.frame} object is (currently) limited to integer,
numeric, or character. In addition, three datetime columns are supported
with the R representations of \code{Date}, \code{POSIXct} and \code{nanotime}.
}
\details{
The created (dense or sparse) array will have as many attributes as there
are columns in the \code{data.frame}.  Each attribute will be a single column.
For a sparse array, one or more columns have to be designated as dimensions.

At present, factor variable are converted to character.
}
\examples{
\dontshow{ctx <- tiledb_ctx(limitTileDBCores())}
uri <- tempfile()
fromDataFrame(iris, uri)
arr <- tiledb_array(uri, return_as="data.frame", extended=FALSE)
newdf <- arr[]
all.equal(iris, newdf, check.attributes=FALSE)  # extra attribute on query in newdf
all.equal(as.matrix(iris), as.matrix(newdf))	# also strips attribute
}
